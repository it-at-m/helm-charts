global:
  realm: <SSO REALM>
  backend:
    name: backend
  frontend:
    name: frontend

configMaps:
  - name: ABC
    data:
      # property-like keys; each key maps to a simple value
      player_initial_lives: "3"
      # file-like keys
      game.properties: |
        enemy.types=aliens,monsters
        player.maximum-lives=5

modules:
  - name: backend
    image:
      repository: ghcr.io/it-at-m/sps/sps-frontend
      # pullPolicy: Always # Defaults to IfNotPresent
      tag: "latest" # Defaults to AppVersion of Chart.yaml
    env:
      # static
      - name: STATIC_ENV_EXAMPLE
        value: someStaticValue
      # single reference dynamic
      - name: SECRET_ENV_EXAMPLE
        valueFrom:
          secretKeyRef:
            key: sps-sample-dev # secret-name
            name: sso-client-id
      - name: SECRET_ENV_EXAMPLE
        valueFrom:
          configMapKeyRef:
            key: sps-sample-dev # secret-name
            name: sso-client-id
    envFrom:
      # whole files of envs
      - configMapRef:
          name: nameOfConfigMap
      - secretRef:
          name: nameOfConfigMap
    volumeMounts:
      - mountPath: /etc/pki/ca-trust/extracted/java
        name: cacerts-lhm
        readOnly: true
    volumes:
      - name: cacerts-lhm
        secret:
          defaultMode: 420
          secretName: cacerts-lhm
          items:
            - key: cacerts-lhm
              path: cacerts
    applicationYML:
      ENV_VARIABLE: someValue # alternative to env.value
      spring:
        profiles:
          active: "myprofile"
    service:
      #type: NodePort   # defaults to ClusterIP
      http: true # adds default http port mapping
      javaDebug: true   # adds default java debug port mapping
      ports:
        - name: myport
          protocol: TCP
          port: 8888
          targetPort: http
    # autoscaling:
    #   minReplicas: 1
    #   maxReplicas: 10
    #   targetCPUUtilizationPercentage: 80
    #   targetMemoryUtilizationPercentage: 80
    # ingress:
    #   # port: 1234    # defaults to 8080
    #   className: ""
    #   # annotations:
    #   #   kubernetes.io/ingress.class: nginx
    #   #   kubernetes.io/tls-acme: "true"
    #   hosts:
    #     - host: chart-example.local
    #       paths:
    #         - path: /
    #           pathType: ImplementationSpecific
    #   # tls:
    #   #  - secretName: chart-example-tls
    #   #    hosts:
    #   #      - chart-example.local
    # replicas: 2 # defaults to 1
    ###########################################################################################

    imagePullSecrets: [ ]
    nameOverride: ""
    fullnameOverride: ""

    serviceAccount:
      # Specifies whether a service account should be created
      create: true
      # Automatically mount a ServiceAccount's API credentials?
      automount: true
      # Annotations to add to the service account
      annotations: { }
      # The name of the service account to use.
      # If not set and create is true, a name is generated using the fullname template
      name: ""


    args:


    securityContext:
      # Security-Settings recommended from https://github.com/Checkmarx/kics
      capabilities:
        drop:
          - ALL
      # readOnlyRootFilesystem: true
      runAsNonRoot: true
      # runAsUser: 1000

    resources:
      { }
      # We usually recommend not to specify default resources and to leave this as a conscious
      # choice for the user. This also increases chances charts run on environments with little
      # resources, such as Minikube. If you do want to specify resources, uncomment the following
      # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
      # limits:
      #   cpu: 100m
      #   memory: 128Mi
      # requests:
    #   cpu: 100m
    #   memory: 128Mi

    startupProbe:
      httpGet:
        path: /actuator/health
        port: http
      initialDelaySeconds: 60
    livenessProbe:
      httpGet:
        path: /actuator/health/liveness
        port: http
    readinessProbe:
      httpGet:
        path: /actuator/health/readiness
        port: http

    nodeSelector: { }

    tolerations: [ ]

    affinity: { }

    extraInitContainers: { }

    lifecycle:
      preStop:
        exec:
          command:
            - sh
            - -c
            - sleep 10



  ## Truststore
  ## If you have custome certificates you can add them in secret as truststore.
  ## The secret you can inject on the right position, so you can override the default truststore.

  # volumeMounts:
  #   - mountPath: /etc/pki/ca-trust/extracted/java
  #     name: cacerts-lhm
  #     readOnly: true
  # volumes:
  #  - name: cacerts-lhm
  #     secret:
  #       defaultMode: 420
  #       secretName: cacerts-lhm
  #       items:
  #         - key: cacerts-lhm
  #           path: cacerts


refarch-gateway:
  envAppend:
    ### Here you see the avaiable config for the apigateway
    ### https://refarch.oss.muenchen.de/gateway.html#configuration
    - name: SPRING_PROFILES_ACTIVE
      value: hazelcast-k8s
    - name: SPRING_SECURITY_OAUTH2_CLIENT_REGISTRATION_SSO_CLIENTID
      valueFrom:
        secretKeyRef:
          key: sps-sample-dev # secret-name
          name: sso-client-id
    - name: SPRING_SECURITY_OAUTH2_CLIENT_REGISTRATION_SSO_CLIENTSECRET
      valueFrom:
        secretKeyRef:
          key: sps-sample-dev # secret-name
          name: sso-client-secret


  applicationYML:
    SSO_ISSUER_URL: https://ssodev.muenchen.de/auth/realms/P82
    HAZELCAST.OPENSHIFT-SERVICE-NAME: digiwf-gateway-service
    ALLOWED_ORIGINS_PUBLIC: https://*.muenchen.de
    ALLOWED_ORIGINS_CLIENTS: https://*.muenchen.de
    spring:
      profiles:
        active: "json-logger,hazelcast-k8s"
      cloud:
        gateway:
          routes:
            - id: "SSO"
              uri: "https://ssodev.muenchen.de/"
              predicates:
                - "Path=/api/sso/userinfo"
              filters:
                - "RewritePath=/api/sso/userinfo, /auth/realms/${SSO_REALM}/protocol/openid-connect/userinfo"
            - id: "backend"
              uri: "http://{{ include \"backend.fullname\" . }}:8080/"
              predicates:
                - "Path=/api/digitalwf-backend-service/rest/**"
              filters:
                - 'RewritePath=/api/digitalwf-backend-service/(?<urlsegments>.*), /$\{urlsegments}'
                - "RemoveResponseHeader=WWW-Authenticate"
            - id: "frontend"
              uri: "http://{{ include \"frontend.fullname\" . }}:8080/"
              predicates:
                - "Path=/**"
              filters:
                - "RemoveResponseHeader=Expires"
                - "RemoveRequestHeader=cookie"
                - "RemoveRequestHeader=x-xsrf-token"
                - "TokenRelay="



  ## This ingress config is spezific to openshift.
  ## If you have plain kubernetes, you will need to change the annotations, className.

  ingress:
    enabled: false
    # annotations:
    #   route.openshift.io/termination: "edge"
    # className: openshift-default
    # hosts:
    #   - host: beispiel.muenchen.de
    #     paths:
    #       - path: /
    #         pathType: "ImplementationSpecific"
    #         backend:
    #           serviceName: '{{ include "refarch-gateway.fullname" . }}'
    #           servicePort: 8080

  ## Truststore
  ## If you have custome certificates you can add them in secret as truststore.
  ## The secret you can inject on the right position, so you can override the default truststore.

  # volumeMounts:
  #   - mountPath: /etc/pki/ca-trust/extracted/java
  #     name: cacerts-lhm
  #     readOnly: true
  # volumes:
  #  - name: cacerts-lhm
  #     secret:
  #       defaultMode: 420
  #       secretName: cacerts-lhm
  #       items:
  #         - key: cacerts-lhm
  #           path: cacerts



